<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Phantom Maze: Pac-Shift (Mobile & Desktop)</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin-top: 20px;
    }
    #gameCanvas {
      background: #111;
      display: block;
      margin: 20px auto;
      border: 2px solid #fff;
      touch-action: none; /* Prevents default swipe behavior */
    }
    #status {
      margin-top: 10px;
      font-size: 1.2em;
    }
    /* Mobile controls container */
    #mobileControls {
      display: none; /* Show only on mobile/small screens */
      margin: 10px;
    }
    .control-btn {
      background: #03dac6;
      border: none;
      color: #000;
      padding: 15px;
      margin: 5px;
      font-size: 1.2em;
      border-radius: 5px;
      width: 60px;
    }
    /* D-Pad layout */
    .dpad {
      display: grid;
      grid-template-areas: 
        "up up up"
        "left center right"
        "down down down";
      grid-gap: 5px;
      justify-items: center;
      align-items: center;
    }
    .dpad button:nth-child(1) { grid-area: up; }
    .dpad button:nth-child(2) { grid-area: left; }
    .dpad button:nth-child(3) { grid-area: right; }
    .dpad button:nth-child(4) { grid-area: down; }
    /* Show mobile controls on smaller screens */
    @media (max-width: 768px) {
      #mobileControls {
        display: block;
      }
    }
  </style>
</head>
<body>
  <h1>Phantom Maze: Pac-Shift</h1>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <div id="status">Score: 0 | Phase Shift: OFF</div>
  
  <!-- Power-up & Reset Buttons -->
  <div id="actionButtons">
    <button id="doubleMoveBtn">Double Move</button>
    <button id="swapMoveBtn">Swap Move</button>
    <button id="resetBtn">Reset Game</button>
  </div>

  <!-- Mobile Controls -->
  <div id="mobileControls">
    <div class="dpad">
      <button class="control-btn" id="btnUp">↑</button>
      <button class="control-btn" id="btnLeft">←</button>
      <button class="control-btn" id="btnRight">→</button>
      <button class="control-btn" id="btnDown">↓</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");
    const doubleMoveBtn = document.getElementById("doubleMoveBtn");
    const swapMoveBtn = document.getElementById("swapMoveBtn");
    const resetBtn = document.getElementById("resetBtn");

    // Grid settings
    const ROWS = 15, COLS = 15;
    const CELL_SIZE = 40; // 600/15 = 40 pixels per cell

    // Maze cell types:
    // 0: empty, 1: permanent wall, 2: dot, 3: phase power-up, 4: shifting wall
    let maze = [];
    let gameOver = false;
    let score = 0;

    // Initialize maze layout randomly
    function initMaze() {
      maze = [];
      for (let r = 0; r < ROWS; r++) {
        let row = [];
        for (let c = 0; c < COLS; c++) {
          if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
            row.push(1);
          } else {
            if (Math.random() < 0.2) {
              row.push(Math.random() < 0.5 ? 4 : 1);
            } else {
              row.push(2);
            }
          }
        }
        maze.push(row);
      }
      // Place two phase power-ups at random dot locations
      let count = 0;
      while (count < 2) {
        let r = Math.floor(Math.random() * ROWS);
        let c = Math.floor(Math.random() * COLS);
        if (maze[r][c] === 2) {
          maze[r][c] = 3;
          count++;
        }
      }
      // Clear starting positions for player and ghost
      maze[1][1] = 0;
      maze[ROWS - 2][COLS - 2] = 0;
    }

    // Player object
    let player = {
      row: 1,
      col: 1,
      phaseShift: false,
      phaseTime: 0
    };

    // Ghost object (one ghost for simplicity)
    let ghosts = [{ row: ROWS - 2, col: COLS - 2 }];

    function updateStatus() {
      statusDiv.innerHTML = "Score: " + score + " | Phase Shift: " +
        (player.phaseShift ? "ON (" + Math.ceil(player.phaseTime / 1000) + "s)" : "OFF");
    }

    // Draw maze grid with walls, dots, and power-ups
    function drawMaze() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let cell = maze[r][c];
          let x = c * CELL_SIZE;
          let y = r * CELL_SIZE;
          if (cell === 1) {
            ctx.fillStyle = "#444"; // permanent wall
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
          } else if (cell === 4) {
            ctx.fillStyle = "#888"; // shifting wall
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
          } else {
            ctx.fillStyle = "#000"; // empty cell
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            if (cell === 2) {
              ctx.fillStyle = "#fff";
              ctx.beginPath();
              ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 4, 0, 2 * Math.PI);
              ctx.fill();
            } else if (cell === 3) {
              ctx.fillStyle = "#0ff";
              ctx.beginPath();
              ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 8, 0, 2 * Math.PI);
              ctx.fill();
            }
          }
        }
      }
    }

    // Draw player (yellow normally, blue in phase mode)
    function drawPlayer() {
      let x = player.col * CELL_SIZE + CELL_SIZE/2;
      let y = player.row * CELL_SIZE + CELL_SIZE/2;
      ctx.beginPath();
      ctx.arc(x, y, CELL_SIZE/2 - 4, 0, 2 * Math.PI);
      ctx.fillStyle = player.phaseShift ? "#00f" : "#ff0";
      ctx.fill();
    }

    // Draw ghost (red normally, orange when fleeing)
    function drawGhosts() {
      ghosts.forEach(ghost => {
        let x = ghost.col * CELL_SIZE + CELL_SIZE/2;
        let y = ghost.row * CELL_SIZE + CELL_SIZE/2;
        ctx.beginPath();
        ctx.arc(x, y, CELL_SIZE/2 - 4, 0, 2 * Math.PI);
        ctx.fillStyle = player.phaseShift ? "#ffa500" : "#f00";
        ctx.fill();
      });
    }

    // Main game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMaze();
      drawPlayer();
      drawGhosts();
      updateStatus();

      if (player.phaseShift) {
        player.phaseTime -= 16;
        if (player.phaseTime <= 0) {
          player.phaseShift = false;
          player.phaseTime = 0;
        }
      }

      if (!gameOver) requestAnimationFrame(gameLoop);
    }

    // Movement function: attempts to move player to a new cell
    function movePlayer(newRow, newCol) {
      if (!gameOver && canMoveTo(newRow, newCol)) {
        player.row = newRow;
        player.col = newCol;
        checkCell(newRow, newCol);
        checkGhostCollision();
      }
    }

    // Check if cell is walkable
    function canMoveTo(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
      let cell = maze[r][c];
      return cell !== 1 && cell !== 4;
    }

    // Process cell actions when moving onto it
    function checkCell(r, c) {
      let cell = maze[r][c];
      if (cell === 2) {
        score += 10;
        maze[r][c] = 0;
      } else if (cell === 3) {
        score += 50;
        player.phaseShift = true;
        player.phaseTime = 10000;
        maze[r][c] = 0;
      }
    }

    // Ghost AI movement (runs every 500ms)
    function moveGhosts() {
      ghosts.forEach(ghost => {
        let directions = [];
        let r = ghost.row, c = ghost.col;
        if (isCellWalkable(r - 1, c)) directions.push({ r: r - 1, c: c });
        if (isCellWalkable(r + 1, c)) directions.push({ r: r + 1, c: c });
        if (isCellWalkable(r, c - 1)) directions.push({ r: r, c: c - 1 });
        if (isCellWalkable(r, c + 1)) directions.push({ r: r, c: c + 1 });
        if (directions.length === 0) return;
        let bestDir = directions[0];
        let bestDist = distance(bestDir.r, bestDir.c, player.row, player.col);
        directions.forEach(dir => {
          let d = distance(dir.r, dir.c, player.row, player.col);
          if (player.phaseShift) {
            if (d > bestDist) { bestDist = d; bestDir = dir; }
          } else {
            if (d < bestDist) { bestDist = d; bestDir = dir; }
          }
        });
        ghost.row = bestDir.r;
        ghost.col = bestDir.c;
      });
      checkGhostCollision();
    }

    // Check if ghost and player collide
    function checkGhostCollision() {
      ghosts.forEach(ghost => {
        if (ghost.row === player.row && ghost.col === player.col) {
          if (player.phaseShift) {
            score += 200;
            ghost.row = ROWS - 2;
            ghost.col = COLS - 2;
          } else {
            gameOver = true;
            updateStatus();
            alert("Game Over! Final Score: " + score);
          }
        }
      });
    }

    // Helper for ghost movement: check walkability for ghosts
    function isCellWalkable(r, c) {
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
      let cell = maze[r][c];
      return cell !== 1 && cell !== 4;
    }

    // Manhattan distance helper
    function distance(r1, c1, r2, c2) {
      return Math.abs(r1 - r2) + Math.abs(c1 - c2);
    }

    // Maze shifting: toggle shifting walls (type 4) every 3 seconds
    function shiftMaze() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (maze[r][c] === 4) {
            maze[r][c] = Math.random() < 0.5 ? 0 : 4;
          }
        }
      }
    }

    // Set intervals for ghost movement and maze shifting
    setInterval(() => { if (!gameOver) moveGhosts(); }, 500);
    setInterval(() => { if (!gameOver) shiftMaze(); }, 3000);

    // Keyboard controls for desktop
    document.addEventListener("keydown", (e) => {
      if (gameOver) return;
      let newRow = player.row;
      let newCol = player.col;
      if (e.key === "ArrowUp") newRow--;
      else if (e.key === "ArrowDown") newRow++;
      else if (e.key === "ArrowLeft") newCol--;
      else if (e.key === "ArrowRight") newCol++;
      movePlayer(newRow, newCol);
    });

    // Mobile on-screen controls
    document.getElementById("btnUp").addEventListener("click", () => movePlayer(player.row - 1, player.col));
    document.getElementById("btnDown").addEventListener("click", () => movePlayer(player.row + 1, player.col));
    document.getElementById("btnLeft").addEventListener("click", () => movePlayer(player.row, player.col - 1));
    document.getElementById("btnRight").addEventListener("click", () => movePlayer(player.row, player.col + 1));

    // Swipe detection for mobile (optional enhancement)
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener("touchstart", (e) => {
      let touch = e.changedTouches[0];
      touchStartX = touch.screenX;
      touchStartY = touch.screenY;
    });
    canvas.addEventListener("touchend", (e) => {
      let touch = e.changedTouches[0];
      let deltaX = touch.screenX - touchStartX;
      let deltaY = touch.screenY - touchStartY;
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (deltaX > 0) movePlayer(player.row, player.col + 1);
        else movePlayer(player.row, player.col - 1);
      } else {
        // Vertical swipe
        if (deltaY > 0) movePlayer(player.row + 1, player.col);
        else movePlayer(player.row - 1, player.col);
      }
    });

    // Action Buttons (Double Move & Swap Move) remain the same as before
    doubleMoveBtn.addEventListener("click", () => {
      if (!gameOver && !doubleMoveUsed[currentPlayer()]) {
        allowedMoves = 2;
        doubleMoveUsed[currentPlayer()] = true;
        doubleMoveBtn.disabled = true;
        updateStatus();
      }
    });
    swapMoveBtn.addEventListener("click", () => {
      if (!gameOver && !swapMoveUsed[currentPlayer()]) {
        swapActive = true;
        swapMoveUsed[currentPlayer()] = true;
        swapMoveBtn.disabled = true;
        updateStatus();
      }
    });
    resetBtn.addEventListener("click", () => {
      score = 0;
      gameOver = false;
      initMaze();
      player.row = 1;
      player.col = 1;
      player.phaseShift = false;
      player.phaseTime = 0;
      ghosts = [{ row: ROWS - 2, col: COLS - 2 }];
      updateStatus();
      requestAnimationFrame(gameLoop);
    });

    // For power-up tracking (dummy functions for now, as original code had similar structure)
    let allowedMoves = 1;
    let doubleMoveUsed = { "X": false, "O": false };
    let swapMoveUsed = { "X": false, "O": false };
    let swapActive = false;
    function currentPlayer() { return "X"; } // Placeholder if needed for power-ups

    // Start game
    function initGame() {
      score = 0;
      gameOver = false;
      initMaze();
      player.row = 1;
      player.col = 1;
      player.phaseShift = false;
      player.phaseTime = 0;
      ghosts = [{ row: ROWS - 2, col: COLS - 2 }];
      updateStatus();
      requestAnimationFrame(gameLoop);
    }
    initGame();
  </script>
</body>
</html>